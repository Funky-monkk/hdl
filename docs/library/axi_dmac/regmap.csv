Address ,,,,,,
DWORD ,BYTE ,Bits ,Name ,Type ,Default ,Description
0x000 ,0x0000 ,,VERSION ,,,Version of the peripheral. Follows semantic versioning. Current version 4.04.61.
,,[31:16] ,VERSION_MAJOR ,RO ,0x04 ,
,,[15:8] ,VERSION_MINOR ,RO ,0x03 ,
,,[7:0] ,VERSION_PATCH ,RO ,0x61 ,
0x001 ,0x0004 ,,PERIPHERAL_ID ,,,
,,[31:0] ,PERIPHERAL_ID ,RO ,ID ,Value of the ID configuration parameter.
0x002 ,0x0008 ,,SCRATCH ,,,
,,[31:0] ,SCRATCH ,RW ,0x00000000 ,Scratch register useful for debug.
0x003 ,0x000c ,,IDENTIFICATION ,,,
,,[31:0] ,IDENTIFICATION ,RO ,0x444D4143 ,"Peripheral identification ('D', 'M', 'A', 'C'). "
0x004 ,0x0010 ,,INTERFACE_DESCRIPTION ,,,
,,[3:0] ,BYTES_PER_BEAT_DEST_LOG2 ,R ,log2(DMA_DATA_WIDTH_DEST/8) ,Width of data bus on destination interface. Log2 of interface data widths in bytes.
,,[5:4] ,DMA_TYPE_DEST ,R ,DMA_TYPE_DEST ,"Value of DMA_TYPE_DEST parameter.(0 - AXI MemoryMap, 1 - AXI Stream, 2 - FIFO "
,,[11:8] ,BYTES_PER_BEAT_SRC_LOG2 ,R ,log2(DMA_DATA_WIDTH_SRC/8) ,Width of data bus on source interface. Log2 of interface data widths in bytes.
,,[13:12] ,DMA_TYPE_SRC ,R ,DMA_TYPE_SRC ,"Value of DMA_TYPE_SRC parameter.(0 - AXI MemoryMap, 1 - AXI Stream, 2 - FIFO "
,,[19:16] ,BYTES_PER_BURST_WIDTH ,R ,BYTES_PER_BURST_WIDTH ,Value of BYTES_PER_BURST_WIDTH interface parameter. Log2 of the real MAX_BYTES_PER_BURST. The starting address of the transfer must be aligned with MAX_BYTES_PER_BURST to avoid crossing the 4kB address boundary.
0x020 ,0x0080 ,,IRQ_MASK ,,,
,,[1] ,TRANSFER_COMPLETED ,RW ,0x1 ,Masks the TRANSFER_COMPLETED IRQ.
,,[0] ,TRANSFER_QUEUED ,RW ,0x1 ,Masks the TRANSFER_QUEUED IRQ.
0x021 ,0x0084 ,,IRQ_PENDING ,,,
,,[1] ,TRANSFER_COMPLETED ,RW1C ,0x0 ,This bit will be asserted if a transfer has been completed and the TRANSFER_COMPLETED bit in the IRQ_MASK register is not set. Either if all bytes have been transferred or an error occurred during the transfer.
,,[0] ,TRANSFER_QUEUED ,RW1C ,0x0 ,This bit will be asserted if a transfer has been queued and it is possible to queue the next transfer. It can be masked out by setting the TRANSFER_QUEUED bit in the IRQ_MASK register.
0x022 ,0x0088 ,,IRQ_SOURCE ,,,
,,[1] ,TRANSFER_COMPLETED ,RO ,0x0 ,This bit will be asserted if a transfer has been completed. Either if all bytes have been transferred or an error occurred during the transfer. Cleared together with the corresponding IRQ_PENDING bit.
,,[0] ,TRANSFER_QUEUED ,RO ,0x0 ,This bit will be asserted if a transfer has been queued and it is possible to queue the next transfer. Cleared together with the corresponding IRQ_PENDING bit.
0x100 ,0x0400 ,,CONTROL ,,,
,,[1] ,PAUSE ,RW ,0x0 ,When set to 1 the currently active transfer is paused. It will be resumed once the bit is cleared again.
,,[0] ,ENABLE ,RW ,0x0 ,When set to 1 the DMA channel is enabled.
0x101 ,0x0404 ,,TRANSFER_ID ,,,
,,[1:0] ,TRANSFER_ID ,RO ,0x00 ,This register contains the ID of the next transfer. The ID is generated by the DMAC and after the transfer has been started can be used to check if the transfer has finished by checking the corresponding bit in the TRANSFER_DONE register. The contents of this register is only valid if TRANSFER_SUBMIT is 0.
0x102 ,0x0408 ,,TRANSFER_SUBMIT ,,,
,,[0] ,TRANSFER_SUBMIT ,RW ,0x00 ,Writing a 1 to this register queues a new transfer. The bit transitions back to 0 once the transfer has been queued or the DMA channel is disabled. Writing a 0 to this register has no effect.
0x103 ,0x040c ,FLAGS ,,,,
,,[0] ,CYCLIC ,RW ,CYCLIC ,Setting this field to 1 puts the DMA transfer into cyclic mode. In cyclic mode the controller will re-start a transfer again once it has finished. In cyclic mode no end-of-transfer interrupts will be generated.
,,[1] ,TLAST ,RW ,0x1 ,When setting this bit for a MM to AXIS transfer the TLAST signal will be asserted during the last beat of the transfer. For AXIS to MM transfers the TLAST signal from the AXIS interface is monitored. After its occurrence all descriptors are ignored until this bit is set.
,,[2] ,PARTIAL_REPORTING_EN ,RW ,0x0 ,When setting this bit the length of partial transfers caused eventually by TLAST will be recorded.
0x104 ,0x0410 ,,DEST_ADDRESS ,,,
,,[31:0] ,DEST_ADDRESS ,RW ,0x00000000 ,This register contains the destination address of the transfer. The address needs to be aligned to the bus width. This register is only valid if the DMA channel has been configured for write to memory support.
0x105 ,0x0414 ,,SRC_ADDRESS ,,,
,,[31:0] ,SRC_ADDRESS ,RW ,0x00000000 ,This register contains the source address of the transfer. The address needs to be aligned to the bus width. This register is only valid if the DMA channel has been configured for read from memory support.
0x106 ,0x0418 ,,X_LENGTH ,,,
,,[23:0] ,X_LENGTH ,RW ,"{log2(max(
DMA_DATA_WIDTH_SRC,
DMA_DATA_WIDTH_DEST
)/8){1'b1}} ",Number of bytes to transfer - 1.
0x107 ,0x041c ,,Y_LENGTH ,,,
,,[23:0] ,Y_LENGTH ,RW ,0x000000 ,"Number of rows to transfer - 1. Note, this field is only valid if the DMA channel has been configured with 2D transfer support. "
0x108 ,0x0420 ,,DEST_STRIDE ,,,
,,[23:0] ,DEST_STRIDE ,RW ,0x000000 ,"The number of bytes between the start of one row and the next row for the destination address. Needs to be aligned to the bus width. Note, this field is only valid if the DMA channel has been configured with 2D transfer support and write to memory support. "
0x109 ,0x0424 ,,SRC_STRIDE ,,,
,,[23:0] ,SRC_STRIDE ,RW ,0x000000 ,"The number of bytes between the start of one row and the next row for the source address. Needs to be aligned to the bus width. Note, this field is only valid if the DMA channel has been configured with 2D transfer and read from memory support. "
0x10a ,0x0428 ,,TRANSFER_DONE ,,,If bit x is set in this register the transfer with ID x has been completed. The bit will automatically be cleared when a new transfer with this ID is queued and will be set when the transfer has been completed.
,,[0] ,TRANSFER_0_DONE ,RO ,0x0 ,If this bit is set the transfer with ID 0 has been completed.
,,[1] ,TRANSFER_1_DONE ,RO ,0x0 ,If this bit is set the transfer with ID 1 has been completed.
,,[2] ,TRANSFER_2_DONE ,RO ,0x0 ,If this bit is set the transfer with ID 2 has been completed.
,,[3] ,TRANSFER_3_DONE ,RO ,0x0 ,If this bit is set the transfer with ID 3 has been completed.
,,[31] ,PARTIAL_TRANSFER_DONE ,RO ,0x0 ,If this bit is set at least one partial transfer was transferred. This field will reset when the ENABLE control bit is reset or when all information on partial transfers was read through PARTIAL_TRANSFER_LENGTH and PARTIAL_TRANSFER_ID registers.
0x10b ,0x042c ,,ACTIVE_TRANSFER_ID ,,,
,,[4:0] ,ACTIVE_TRANSFER_ID ,RO ,0x00 ,ID of the currently active transfer. When no transfer is active this register will be equal to the TRANSFER_ID register.
0x10c ,0x0430 ,,STATUS ,,,
,,[31:0] ,RESERVED ,RO ,0x00 ,This register is reserved for future usage. Reading it will always return 0.
0x10d ,0x0434 ,,CURRENT_DEST_ADDRESS ,,,
,,[31:0] ,CURRENT_DEST_ADDRESS ,RO ,0x00 ,Address to which the next data sample is written to. This register is only valid if the DMA channel has been configured for write to memory support.
0x10e ,0x0438 ,,CURRENT_SRC_ADDRESS ,,,
,,[31:0] ,CURRENT_SRC_ADDRESS ,RO ,0x00 ,Address form which the next data sample is read. This register is only valid if the DMA channel has been configured for read from memory support.
0x112 ,0x0448 ,,TRANSFER_PROGRESS ,,,
,,[23:0] ,TRANSFER_PROGRESS ,RO ,0x000000 ,This field presents the number of bytes transferred to the destination for the current transfer. This register will be cleared once the transfer completes. This should be used for debugging purposes only.
0x113 ,0x044c ,,PARTIAL_TRANSFER_LENGTH ,,,
,,[31:0] ,PARTIAL_LENGTH ,RO ,0x000000 ,Length of the partial transfer in bytes. Represents the number of bytes received until the moment of TLAST assertion. This will be smaller than the programmed length from the X_LENGTH and Y_LENGTH registers.
0x114 ,0x0450 ,,PARTIAL_TRANSFER_ID ,,,Must be read after the PARTIAL_TRANSFER_LENGTH registers.
,,[1:0] ,PARTIAL_TRANSFER_ID ,RO ,0x0 ,ID of the transfer that was partial.
0x124 ,0x0490 ,,DEST_ADDRESS_HIGH ,,,
,,[31:0] ,DEST_ADDRESS_HIGH ,RW ,0x00000000 ,This register contains the HIGH segment of the destination address of the transfer. This register is only valid if the DMA_AXI_ADDR_WIDTH is bigger than 32 and if DMA channel has been configured for write to memory support.
0x125 ,0x0494 ,,SRC_ADDRESS_HIGH ,,,
,,[31:0] ,SRC_ADDRESS_HIGH ,RW ,0x00000000 ,This register contains the HIGH segment of the source address of the transfer. This register is only valid if the DMA_AXI_ADDR_WIDTH is bigger than 32 and if the DMA channel has been configured for read from memory support.
0x126 ,0x0498 ,,CURRENT_DEST_ADDRESS_HIGH ,,,
,,[31:0] ,CURRENT_DEST_ADDRESS_HIGH ,RO ,0x00 ,HIGH segment of the address to which the next data sample is written to. This register is only valid if the DMA_AXI_ADDR_WIDTH is bigger than 32 and if the DMA channel has been configured for write to memory support.
0x127 ,0x049c ,,CURRENT_SRC_ADDRESS_HIGH ,,,
,,[31:0] ,CURRENT_SRC_ADDRESS_HIGH ,RO ,0x00 ,HIGH segment of the address from which the next data sample is read. This register is only valid if the DMA_AXI_ADDR_WIDTH is bigger than 32 and if the DMA channel has been configured for read from memory support.
,,,,,,Tue Mar 14 10:17:59 2023
